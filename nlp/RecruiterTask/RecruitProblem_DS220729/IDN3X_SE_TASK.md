# Recruitment Task
#recruitment 

### 1. Извличане на информация от неструктуриран текст
Във файла `of_mice_new.txt` се съдържа текстът на романа *"Of Mice and Men"*. Задачата е да се извлече програматично информация за имената на героите в нея и техните споменавания.

- [ ] _Изчети_ текстовия файл и съхрани съдържанието му в удобен за обрабтока формат, разделяйки го на изречения.
- [ ] Извлечи всички именувани обекти в текста, открити от **готов** (и по възможност лек) Named Entity Recognition (NER) модел. Препоръчваме някой от тези [Spacy](https://spacy.io/models/en) модели. Използвай официалният [гайд](https://spacy.io/usage/models) и [докумнетация](https://spacy.io/api/entityrecognizer) за да се ориентираш в употребата им за целта на задачата.
- [ ] Филтрирай само имената на хора (_герои_) извлечени от NER модела.
- [ ] Съхрани в подходяща структура от данни информация за споменаванията на героите в изреченията от романа.
- [ ] Установи колко пъти, в колко и кои изречения се с среща всяко едно име на герой.
- [ ] Установи изречения, в които даден герой се среща в комбинации заедно с други герои.
- [ ] Приложи техники по свой избор за да идентифицираш алтернативни форми на споменаване на героите и да асоциираш всички споменавания с уникална форма на имената им.
- [ ] Установи как това променя статистиките за техните споменавания.
- [ ] Използвай тази и по преценка друга извлечена от текста информация, за да определиш метод за автоматична категоризация на героите в ранг от 1 до 3, съответстващ на главни, второстепенни или епизодични литературни герои.
 - [ ] Използвай информация и/или модели по твоя преценка, за да определиш метод за автоматична категоризация на героите като тип - позитивен, неутрален, негативен.
 - [ ] Оцени представянето на приложения подход върху последните две семантични задачи, позовавайки се на определена базова истина.

### 2. Доставяне на услугата през REST API

Създай уеб приложение с GET и/или POST методи, реализиращо WSGI/ASGI със следните endpoints за доставка на услуги:

- [ ] `get_character_info` - очаква `name` параметър и в случай, че той съвпада с име на герой от книгата, връща JSON схема съдържаща:
	-  `rank` : неговия ранг (1-3);
	-  `mentions_count` : броя на всички негови споменавания;
	-  `mono_mentions_count` : броя изречения, в които името на героя се среща само;
	-  `co_mentions_count` : броя изречения, в които то се среща заедно с други имена на герои;
	-  `co_mention_names` : имената на героите заедно с които се среща в едно и също изречение;

- [ ] `get_main_characters` - връща JSON схемата от `get_character_info` за всички главни (ранг-1) герои;
- [ ] `get_support_characters` - връща JSON схемата от `get_character_info` за топ-10 второстепенни (ранг-2) герои;
- [ ] `get_episode_characters` - връща JSON схемата от `get_character_info` за 10 произволни епизодични (ранг-3) герои;

- [ ] `get_character_menitons` - очаква `name` параметър и в случай, че той съвпада с име на герой от книгата, връща списък с всички изречения, в които името му се споменава; в случай че не получи `name` параметър връща такива списъци за всички главни герой;
- [ ] `get_characters_coreference` -  очаква `name_a`, `name_b` параметри и в случай, че те съвпадат с имена на герои от книгата, връща всички изречения, в които те се споменават заедно, ако има такива.

- [ ] Добави API endpoint(s) с друга функционалност по своя идея.

- [ ] **ЗА БОНУС ТОЧКИ:** Пакетирай цялото приложение в докер имидж (Dockerfile), който да можем да тестваме с docker build / docker run.

Очаква се всеки АPI endpoint на приложението да връща валиден отговор съдържащ съобщение/информация за грешка в случай, че получи невалидна заявка или стойност на параметър, която не съвпада с име на герой от книгата.

### Изисквания
- **Използвай Python >= 3.6** и всякакви съвместими open source пакети които желаеш.
- Кодът и приложението трябва да могат да се изпълнят на стандартна работна машина.
- Можеш да използваш Jupyter notebooks за бърза прототипизация и/или достъпна публикация на решението на задачите от част 1, но това **не е изискване**.
- Целият код за решенията и на двете части трябва да бъде качен заедно с всякакви съпътстващи файлове в github на `main` branch-a на това private репозитори.
- При готовност с решението на задачата кандидатът го публикува и ни известява за да изготвим обратна връзка, посредством **pull-request**.
- Задължително изготви `README.md` документация, описваща изпълнениетo на кода от част 1, пускането и употребата на приложението от част 2.
- Всякаква друга написана или автоматично генерирана документация, добре форматиран log/output или визуализация са в твой плюс!
- Няма изискване за съхраняване на извлечената информация от част 1 в конкретен вид база данни за целите на част 2, но имаш свободата да използваш всякакъв удобен за теб модел или да демонстрираш опита си в тази област ако желаеш.
- ***Забележка:*** *Решението на задачата в част 2 стъпва върху това от част 1, но те тестват и оценяват различни умения и е добре в случай, че не си доволен от резултата си в част 1, да разработиш възможно най-добро приложение в част 2!*
- ***Забележка:*** *Решения, които не могат да бъдат изпълнени, няма да бъдат разглеждани!*
